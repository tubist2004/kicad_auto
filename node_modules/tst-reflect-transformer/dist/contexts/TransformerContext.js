"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const config_1 = require("../config");
const MetadataWriterFactory_1 = require("../meta-writer/factories/MetadataWriterFactory");
const UnknownPackageName = "@@this";
const InstanceKey = Symbol.for("tst-reflect.TransformerContext");
let instance = global[InstanceKey] || null;
class TransformerContext {
    constructor() {
        if (new.target != Activator) {
            throw new Error("This constructor is protected.");
        }
    }
    static get instance() {
        if (!instance) {
            instance = Reflect.construct(TransformerContext, [], Activator);
        }
        return instance;
    }
    get metaWriter() {
        if (!this._metaWriter) {
            throw new Error("TransformerContext has not been initiated yet.");
        }
        return this._metaWriter;
    }
    get config() {
        if (!this._config) {
            throw new Error("TransformerContext has not been initiated yet.");
        }
        return this._config;
    }
    get tsConfig() {
        if (!this._tsConfig) {
            throw new Error("TransformerContext has not been initiated yet.");
        }
        return this._tsConfig;
    }
    init(program, config) {
        this.prepareConfig(program, config);
        this.program = program;
        if (!this._metaWriter) {
            this._metaWriter = MetadataWriterFactory_1.MetadataWriterFactory.create(this);
        }
    }
    prepareConfig(program, config) {
        this._tsConfig = program.getCompilerOptions();
        const rootDir = path.resolve(this._tsConfig.rootDir || program.getCurrentDirectory());
        const packageInfo = this.getPackage(rootDir);
        this._config = (0, config_1.createConfig)(this._tsConfig, rootDir, packageInfo, config);
    }
    getPackage(root, recursiveCheck = false) {
        try {
            const packageJson = fs.readFileSync(path.join(root, "package.json"), "utf-8");
            return { rootDir: root, name: JSON.parse(packageJson).name || UnknownPackageName };
        }
        catch (e) {
            if (path.parse(root).root == root) {
                return { rootDir: undefined, name: UnknownPackageName };
            }
            const packageInfo = this.getPackage(path.normalize(path.join(root, "..")), true);
            if (packageInfo.rootDir == undefined) {
                if (recursiveCheck) {
                    return packageInfo;
                }
                return { rootDir: root, name: packageInfo.name };
            }
            return packageInfo;
        }
    }
}
exports.default = TransformerContext;
class Activator extends TransformerContext {
}
//# sourceMappingURL=TransformerContext.js.map