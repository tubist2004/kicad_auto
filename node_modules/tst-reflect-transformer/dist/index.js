"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const SourceFileContext_1 = require("./contexts/SourceFileContext");
const TransformerContext_1 = require("./contexts/TransformerContext");
const log_1 = require("./log");
function transform(program, options) {
    TransformerContext_1.default.instance.init(program, options);
    if (!process["tstReflectInit"]) {
        log_1.log.log(log_1.LogLevel.Info, log_1.color.cyan, `using tsconfig '${TransformerContext_1.default.instance.config.tsConfigPath}'.`);
        log_1.log.log(log_1.LogLevel.Info, log_1.color.cyan, `detected root directory '${TransformerContext_1.default.instance.config.rootDir}'.`);
        process["tstReflectInit"] = "1";
    }
    return (context) => {
        return (node) => ts.visitNode(node, getVisitor(context, program));
    };
}
exports.default = transform;
function getVisitor(context, program) {
    const typeChecker = program.getTypeChecker();
    const transformerContext = TransformerContext_1.default.instance;
    const config = transformerContext.config;
    return node => {
        if (!ts.isSourceFile(node)) {
            return node;
        }
        if (config.debugMode) {
            log_1.log.log(log_1.LogLevel.Trace, log_1.color.cyan, `Visitation of file ${node.fileName} started.`);
        }
        const sourceFileContext = new SourceFileContext_1.default(transformerContext, context, program, typeChecker, node);
        let visitedNode = sourceFileContext.context.visit(node);
        if (visitedNode && sourceFileContext.typesMetadata.length) {
            if (config.useMetadata) {
                const propertiesStatements = [];
                const typeIdUniqueObj = {};
                for (let [typeId, properties] of sourceFileContext.typesMetadata) {
                    if (typeIdUniqueObj[typeId]) {
                        continue;
                    }
                    typeIdUniqueObj[typeId] = true;
                    propertiesStatements.push([typeId, properties]);
                }
                const typeCtor = new Set();
                for (let ctor of sourceFileContext.typesCtors) {
                    typeCtor.add(ctor);
                }
                transformerContext.metaWriter.writeMetaProperties(propertiesStatements, typeCtor, context);
            }
            visitedNode = updateSourceFile(sourceFileContext, visitedNode);
        }
        if (config.debugMode) {
            log_1.log.trace(`Visitation of file ${node.fileName} has been finished.`);
        }
        visitedNode = transformerContext.metaWriter.addLibImportToSourceFile(visitedNode);
        return visitedNode;
    };
}
function updateSourceFile(sourceFileContext, visitedNode) {
    const statements = [];
    const typeIdUniqueObj = {};
    if (!TransformerContext_1.default.instance.config.useMetadata) {
        for (let [typeId, properties] of sourceFileContext.typesMetadata) {
            if (typeIdUniqueObj[typeId]) {
                continue;
            }
            typeIdUniqueObj[typeId] = true;
            statements.push(ts.factory.createExpressionStatement(sourceFileContext.metaWriter.factory.addDescriptionToStore(typeId, properties)));
        }
    }
    const importsCount = visitedNode.statements.findIndex(s => !ts.isImportDeclaration(s));
    if (importsCount == -1) {
        log_1.log.warn("Reflection: getType<T>() used, but no import found.");
    }
    const finalizedStatements = importsCount == -1
        ? [...statements, ...visitedNode.statements]
        : visitedNode.statements.slice(0, importsCount).concat(statements).concat(visitedNode.statements.slice(importsCount));
    return ts.factory.updateSourceFile(visitedNode, finalizedStatements);
}
//# sourceMappingURL=index.js.map