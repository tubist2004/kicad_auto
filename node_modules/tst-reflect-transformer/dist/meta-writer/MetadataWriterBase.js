"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataWriterBase = void 0;
const fs = require("fs");
const path = require("path");
const ts = require("typescript");
const config_options_1 = require("../config-options");
const helpers_1 = require("../helpers");
const log_1 = require("../log");
const NodeGenerator_1 = require("../NodeGenerator");
class MetadataWriterBase {
    constructor(metadataFilePath, context, metadataNodeGenerator, metadataTransformerFactory, inFileGetTypeIdentifier = ts.factory.createIdentifier("_tst_reflect_set"), metaFileGetTypeIdentifier = ts.factory.createIdentifier("_tst_reflect_set")) {
        this.type = config_options_1.MetadataTypeValues.inline;
        this._addedMetaForSourceFile = [];
        this._addedLibImport = [];
        this.context = context;
        this.metadataFilePath = metadataFilePath;
        this.inFileGetTypeIdentifier = inFileGetTypeIdentifier;
        this.metaFileGetTypeIdentifier = metaFileGetTypeIdentifier;
        this.metadataNodeGenerator = metadataNodeGenerator;
        this.metadataTransformer = metadataTransformerFactory.create(metaFileGetTypeIdentifier);
        this.tsPrinter = ts.createPrinter();
        this.metaSourceFile = this.createLibFile();
    }
    getStubFile(stubFileName) {
        if (!this.context.program) {
            throw new Error("[Extended Meta Lib] : Program is not attached to context?");
        }
        let sourcePath = path.resolve(__dirname, "..", "..", "meta-templates", stubFileName);
        const stubSrcContents = fs.readFileSync(sourcePath, "utf-8");
        return ts.createSourceFile(this.metadataFilePath, stubSrcContents, ts.ScriptTarget.ES2015);
    }
    createBaseMeta() {
        if (!this.isUsingLibFile()) {
            return;
        }
        let statements = [];
        if (this.usesStubFile() && this.metaSourceFile) {
            statements = [...this.metaSourceFile.statements];
        }
        else {
            const { statement, getTypeIdentifier } = NodeGenerator_1.nodeGenerator.createGetTypeImport();
            this.inFileGetTypeIdentifier = getTypeIdentifier;
            statements = [statement];
        }
        this.writeSourceFile(this.createMetaSourceFile(statements));
        this.logMessage(`Wrote lib file to ${this.metadataFilePath}`);
    }
    writeTranspiledMetaSourceFile() {
        var _a;
        if (!this.metaSourceFile) {
            return;
        }
        const source = this.writeSourceFile(this.metaSourceFile);
        this.logMessage(`Wrote updated lib file to ${this.metadataFilePath}`);
        if (!source) {
            return;
        }
        const parsedCommandLine = this.context.config.parsedCommandLine;
        let outFileName = undefined;
        if (parsedCommandLine) {
            outFileName = (0, helpers_1.getOutPathForSourceFile)(this.metaSourceFile.fileName, this.context, false);
        }
        if (!outFileName) {
            const pathParsed = path.parse(this.metaSourceFile.fileName);
            outFileName = this.metaSourceFile.fileName
                .replace("src/", "dist/")
                .replace(pathParsed.base, pathParsed.name) + ".js";
        }
        const res = ts.transpileModule(source, {
            fileName: outFileName,
            compilerOptions: (_a = this.context.program) === null || _a === void 0 ? void 0 : _a.getCompilerOptions()
        });
        if (res) {
            fs.mkdirSync(path.dirname(outFileName), { recursive: true });
            fs.writeFileSync(outFileName, res.outputText, "utf8");
        }
    }
    writeMetaProperties(typesProperties, typesCtors, transformationContext) {
        if (!this.metaSourceFile) {
            return;
        }
        const properties = this.metadataTransformer.transformMetaProperties(this.metaSourceFile, typesProperties, typesCtors, transformationContext);
        this.metaSourceFile = this.metadataTransformer.transformMetaLibSourceFileStatements(this.metaSourceFile, properties);
        this.writeTranspiledMetaSourceFile();
    }
    addLibImportToSourceFile(sourceFile) {
        if (!this.metaSourceFile) {
            return sourceFile;
        }
        if (sourceFile.fileName.includes(this.metaSourceFile.fileName)) {
            return sourceFile;
        }
        if (this.hasAddedMetaLibImport(sourceFile.fileName)) {
            return sourceFile;
        }
        const relative = this.getRelativeMetaLibPath(sourceFile);
        this.logMessage(`Added lib import to source file:${sourceFile.fileName}`);
        this.addedMetaLibImport(sourceFile.fileName);
        return ts.factory.updateSourceFile(sourceFile, [
            ...this.metadataNodeGenerator.sourceFileMetaLibStatements(relative),
            ...sourceFile.statements
        ]);
    }
    is(type) {
        return this.type === type;
    }
    isUsingStubFile() {
        return this.usesStubFile()[0];
    }
    isUsingLibFile() {
        return this.metaSourceFile !== undefined;
    }
    createLibFile() {
        const [usesStub, stubFileName] = this.usesStubFile();
        if (usesStub && stubFileName) {
            return this.getStubFile(stubFileName);
        }
        return undefined;
    }
    createMetaSourceFile(statements) {
        return ts.factory.createSourceFile(statements, ts.factory.createToken(ts.SyntaxKind.EndOfFileToken), ts.NodeFlags.None);
    }
    writeSourceFile(sourceFile) {
        sourceFile = sourceFile !== null && sourceFile !== void 0 ? sourceFile : this.metaSourceFile;
        if (!sourceFile) {
            return;
        }
        const source = this.tsPrinter.printFile(sourceFile);
        fs.writeFileSync(this.metadataFilePath, source, { encoding: "utf8", flag: "w" });
        return source;
    }
    getRelativeMetaLibPath(relativeToSourceFile) {
        return (0, helpers_1.getRequireRelativePath)(relativeToSourceFile.fileName, this.metadataFilePath);
    }
    logMessage(message, ...args) {
        if (this.context.config.debugMode) {
            log_1.log.log(log_1.LogLevel.Trace, log_1.color.magenta, `[${this.type}] : ${message}`, ...(args || []));
        }
    }
    hasWrittenMetaForFile(filePath) {
        return this._addedMetaForSourceFile.includes(filePath);
    }
    metaWrittenForFile(filePath) {
        this._addedMetaForSourceFile.push(filePath);
    }
    hasAddedMetaLibImport(fileName) {
        return this._addedLibImport.includes(fileName);
    }
    addedMetaLibImport(fileName) {
        this._addedLibImport.push(fileName);
    }
    get factory() {
        return this.metadataNodeGenerator;
    }
}
exports.MetadataWriterBase = MetadataWriterBase;
//# sourceMappingURL=MetadataWriterBase.js.map