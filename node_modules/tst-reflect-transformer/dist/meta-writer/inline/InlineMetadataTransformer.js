"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InlineMetadataTransformer = void 0;
const tst_reflect_1 = require("tst-reflect");
const ts = require("typescript");
class InlineMetadataTransformer {
    constructor(getTypeIdentifier) {
        this.getTypeIdentifier = getTypeIdentifier;
    }
    transformMetaLibSourceFileStatements(sourceFile, statements) {
        return ts.factory.updateSourceFile(sourceFile, statements, sourceFile.isDeclarationFile, sourceFile.referencedFiles, sourceFile.typeReferenceDirectives, sourceFile.hasNoDefaultLib, sourceFile.libReferenceDirectives);
    }
    transformMetaProperties(sourceFile, typesProperties, typesCtors, transformationContext) {
        const propertiesStatements = [];
        for (let [typeId, properties] of typesProperties) {
            const updatedProperties = ts.visitEachChild(properties, this.transformGetTypeIdentifiers(transformationContext), transformationContext);
            propertiesStatements.push(ts.factory.createExpressionStatement(ts.factory.createCallExpression(this.getTypeIdentifier, [], [
                ts.factory.createNumericLiteral(typeId), updatedProperties
            ])));
        }
        return propertiesStatements;
    }
    transformGetTypeIdentifiers(transformationContext) {
        return node => {
            if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) && node.expression.escapedText == tst_reflect_1.GET_TYPE_FNC_NAME) {
                return ts.factory.updateCallExpression(node, this.getTypeIdentifier, node.typeArguments, ts.visitNodes(node.arguments, this.transformGetTypeIdentifiers(transformationContext)));
            }
            return ts.visitEachChild(node, this.transformGetTypeIdentifiers(transformationContext), transformationContext);
        };
    }
}
exports.InlineMetadataTransformer = InlineMetadataTransformer;
//# sourceMappingURL=InlineMetadataTransformer.js.map