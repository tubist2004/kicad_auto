"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processGenericCallExpression = void 0;
const ts = require("typescript");
const getGenericParametersDetails_1 = require("./getGenericParametersDetails");
const getNodeLocationText_1 = require("./getNodeLocationText");
const getTypeCall_1 = require("./getTypeCall");
const helpers_1 = require("./helpers");
const log_1 = require("./log");
const updateCallExpression_1 = require("./updateCallExpression");
function processGenericCallExpression(node, fncType, context) {
    var _a, _b, _c, _d, _e;
    if (!((_a = fncType.symbol) === null || _a === void 0 ? void 0 : _a.declarations)) {
        if (context.config.debugMode) {
            context.log.debug("Unable to resolve declaration of the generic type's symbol signature.\r\n" + (0, getNodeLocationText_1.getNodeLocationText)(node));
        }
        return undefined;
    }
    const declaration = (fncType.symbol.declarations.length > 1
        ? (((_b = context.typeChecker.getResolvedSignature(node)) === null || _b === void 0 ? void 0 : _b.declaration)
            || context.typeChecker.getSignaturesOfType(fncType, ts.SignatureKind.Call))
        : fncType.symbol.declarations[0]);
    if (!declaration) {
        log_1.log.error("Unable to resolve declaration of symbol signature.");
        return undefined;
    }
    const state = (0, getGenericParametersDetails_1.getGenericParametersDetails)(declaration, context, fncType.symbol.declarations);
    if (state && state.usedGenericParameters && state.indexesOfGenericParameters) {
        const args = [];
        let i = 0;
        for (let genericParamName of state.usedGenericParameters) {
            let typeArgumentNode = (_c = node.typeArguments) === null || _c === void 0 ? void 0 : _c[state.indexesOfGenericParameters[i]];
            let typePropertyVal;
            let genericType;
            if (typeArgumentNode == undefined) {
                let argsIndex = 0;
                for (const parameter of declaration.parameters) {
                    if (parameter.type) {
                        let type = parameter.type, isArrayTypeNode;
                        if ((isArrayTypeNode = ts.isArrayTypeNode(parameter.type))) {
                            type = parameter.type.elementType;
                        }
                        if (ts.isTypeReferenceNode(type) && type.typeName.getText() == genericParamName) {
                            genericType = context.typeChecker.getTypeAtLocation(node.arguments[argsIndex]);
                            if (isArrayTypeNode && !parameter.dotDotDotToken) {
                                if ((0, helpers_1.isArrayType)(genericType)) {
                                    genericType = (_d = genericType.resolvedTypeArguments) === null || _d === void 0 ? void 0 : _d[0];
                                }
                                else {
                                    genericType = undefined;
                                    break;
                                }
                            }
                            let symbol = context.typeChecker.getSymbolAtLocation(node.arguments[0]);
                            if (symbol) {
                                typeArgumentNode = (_e = symbol.valueDeclaration) === null || _e === void 0 ? void 0 : _e.type;
                            }
                            break;
                        }
                    }
                    argsIndex++;
                }
            }
            if (typeArgumentNode || genericType) {
                genericType !== null && genericType !== void 0 ? genericType : (genericType = context.typeChecker.getTypeAtLocation(typeArgumentNode));
                if (typeArgumentNode && genericType.flags == ts.TypeFlags.TypeParameter) {
                    if (ts.isTypeReferenceNode(typeArgumentNode) && ts.isIdentifier(typeArgumentNode.typeName)) {
                        typePropertyVal = ts.factory.createParenthesizedExpression(ts.factory.createBinaryExpression(ts.factory.createIdentifier(helpers_1.GENERIC_PARAMS), ts.SyntaxKind.AmpersandAmpersandToken, ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(helpers_1.GENERIC_PARAMS), ts.factory.createIdentifier(typeArgumentNode.typeName.escapedText.toString()))));
                    }
                    else {
                        typePropertyVal = (0, helpers_1.getUnknownTypeCall)(context);
                    }
                }
                else {
                    const genericTypeSymbol = genericType.getSymbol();
                    typePropertyVal = (0, getTypeCall_1.getTypeCall)(genericType, genericTypeSymbol, context, typeArgumentNode && ts.isTypeReferenceNode(typeArgumentNode) ? typeArgumentNode.typeName : undefined);
                }
            }
            else {
                typePropertyVal = (0, helpers_1.getUnknownTypeCall)(context);
            }
            args.push({
                genericTypeName: genericParamName,
                reflectedType: typePropertyVal
            });
            i++;
        }
        return (0, updateCallExpression_1.updateCallExpression)(node, state, args);
    }
    return undefined;
}
exports.processGenericCallExpression = processGenericCallExpression;
//# sourceMappingURL=processGenericCallExpression.js.map