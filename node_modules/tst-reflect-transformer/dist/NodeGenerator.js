"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeGenerator = void 0;
const ts = require("typescript");
const log_1 = require("./log");
class NodeGenerator {
    createGetTypeImport(getTypeIdentifier) {
        getTypeIdentifier !== null && getTypeIdentifier !== void 0 ? getTypeIdentifier : (getTypeIdentifier = ts.factory.createIdentifier("_tst_getType"));
        const packageName = ts.factory.createStringLiteral("tst-reflect");
        const getTypeExportNameIdentifier = ts.factory.createIdentifier("getType");
        const statement = ts.factory.createImportDeclaration(undefined, undefined, ts.factory.createImportClause(false, undefined, ts.factory.createNamedImports([
            ts.factory.createImportSpecifier(false, getTypeIdentifier, getTypeExportNameIdentifier)
        ])), packageName);
        return {
            statement,
            getTypeIdentifier
        };
    }
    createImport(importInformation) {
        return this.createEsmImport(importInformation, typeof importInformation.identifier === "string"
            ? ts.factory.createIdentifier(importInformation.identifier)
            : importInformation.identifier);
    }
    createEsmImport(importInformation, identifier) {
        let importClause;
        if ((importInformation === null || importInformation === void 0 ? void 0 : importInformation.isDefault) === true) {
            importClause = ts.factory.createImportClause((importInformation === null || importInformation === void 0 ? void 0 : importInformation.isTypeOnlyImport) === true, identifier, undefined);
        }
        else if ((importInformation === null || importInformation === void 0 ? void 0 : importInformation.namespaceImport) === true) {
            importClause = ts.factory.createImportClause((importInformation === null || importInformation === void 0 ? void 0 : importInformation.isTypeOnlyImport) === true, undefined, ts.factory.createNamespaceImport(identifier));
        }
        else {
            importClause = ts.factory.createImportClause((importInformation === null || importInformation === void 0 ? void 0 : importInformation.isTypeOnlyImport) === true, undefined, ts.factory.createNamedImports([
                ts.factory.createImportSpecifier((importInformation === null || importInformation === void 0 ? void 0 : importInformation.isTypeOnlyImport) === true, undefined, identifier)
            ]));
        }
        return ts.factory.createImportDeclaration(undefined, undefined, importClause, ts.factory.createStringLiteral(importInformation.filePath));
    }
    createObjectLiteralExpressionNode(data) {
        const props = [];
        for (let key of Object.keys(data)) {
            const value = data[key];
            let valueNode = undefined;
            switch (typeof value) {
                case "object":
                    valueNode = this.createObjectLiteralExpressionNode(value);
                    break;
                case "string":
                    valueNode = ts.factory.createStringLiteral(value);
                    break;
                case "boolean":
                    valueNode = value ? ts.factory.createTrue() : ts.factory.createFalse();
                    break;
                case "number":
                    valueNode = ts.factory.createNumericLiteral(value);
                    break;
            }
            if (!valueNode) {
                log_1.log.warn(`Failed to create node for objectLiteralExpressionNode. Value: `, value);
                continue;
            }
            props.push(ts.factory.createPropertyAssignment(ts.factory.createIdentifier(key), valueNode));
        }
        return ts.factory.createObjectLiteralExpression(props, true);
    }
}
exports.nodeGenerator = new NodeGenerator();
//# sourceMappingURL=NodeGenerator.js.map