"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMethods = exports.getMethodGenerics = void 0;
const ts = require("typescript");
const getDecorators_1 = require("./getDecorators");
const getSignatureParameters_1 = require("./getSignatureParameters");
const getTypeCall_1 = require("./getTypeCall");
const helpers_1 = require("./helpers");
function getMethodGenerics(symbol, context) {
    var _a;
    const value = symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration;
    return ((_a = value === null || value === void 0 ? void 0 : value.typeParameters) !== null && _a !== void 0 ? _a : []).map(generic => {
        const type = context.typeChecker.getTypeAtLocation(generic);
        return (0, getTypeCall_1.getTypeCall)(type, symbol, context);
    });
}
exports.getMethodGenerics = getMethodGenerics;
function getMethodDescriptionFromSignature(symbol, methodSignature, context) {
    var _a, _b, _c;
    const returnType = methodSignature.getReturnType();
    return {
        n: symbol.escapedName.toString(),
        params: (0, getSignatureParameters_1.getSignatureParameters)(methodSignature, context),
        rt: (0, getTypeCall_1.getTypeCall)(returnType, returnType.symbol, context) || (0, helpers_1.getUnknownTypeCall)(context),
        d: (0, getDecorators_1.getDecorators)(symbol, context),
        tp: (_b = (_a = methodSignature.getTypeParameters()) === null || _a === void 0 ? void 0 : _a.map(typeParameter => (0, getTypeCall_1.getTypeCall)(typeParameter, typeParameter.symbol, context))) !== null && _b !== void 0 ? _b : [],
        o: (symbol.flags & ts.SymbolFlags.Optional) === ts.SymbolFlags.Optional,
        am: (0, helpers_1.getAccessModifier)((_c = symbol.valueDeclaration) === null || _c === void 0 ? void 0 : _c.modifiers)
    };
}
function getMethods(symbol, type, context) {
    if (!(symbol === null || symbol === void 0 ? void 0 : symbol.members)) {
        return undefined;
    }
    const members = type.getProperties();
    const methods = members
        .filter(m => (m.flags & ts.SymbolFlags.Method) === ts.SymbolFlags.Method || (m.flags & ts.SymbolFlags.Function) === ts.SymbolFlags.Function)
        .flatMap((memberSymbol) => {
        const declaration = (0, helpers_1.getDeclaration)(memberSymbol);
        if (!declaration) {
            return [];
        }
        let type = context.typeChecker.getTypeOfSymbolAtLocation(memberSymbol, declaration);
        if (type.isUnion()) {
            type = (type.types[0].flags === ts.TypeFlags.Undefined ? type.types[1] : type.types[0]) || type;
        }
        return type.getCallSignatures().map(signature => getMethodDescriptionFromSignature(memberSymbol, signature, context));
    });
    return methods.length ? methods : undefined;
}
exports.getMethods = getMethods;
//# sourceMappingURL=getMethods.js.map