"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConfig = void 0;
const path_1 = require("path");
const ts = require("typescript");
const typescript_1 = require("typescript");
const config_options_1 = require("./config-options");
const helpers_1 = require("./helpers");
function getConfigReflectionSection(configPath) {
    var _a, _b, _c, _d;
    if (!configPath) {
        return {
            mode: config_options_1.ModeValues.universal,
            debugMode: false,
            metadata: {
                type: config_options_1.MetadataTypeValues.inline,
                filePath: ""
            },
            deno: false
        };
    }
    const result = ts.readConfigFile(configPath, ts.sys.readFile);
    if (result.error) {
        throw new Error(`${helpers_1.PACKAGE_ID}: tsconfig.json error: ${result.error.messageText}`);
    }
    const reflection = ((_a = result.config) === null || _a === void 0 ? void 0 : _a.reflection) || {};
    return {
        mode: reflection.mode || config_options_1.ModeValues.universal,
        debugMode: reflection.debugMode || false,
        metadata: {
            type: ((_b = reflection.metadata) === null || _b === void 0 ? void 0 : _b.type) || config_options_1.MetadataTypeValues.inline,
            filePath: ((_d = (_c = reflection.metadata) === null || _c === void 0 ? void 0 : _c.filePath) === null || _d === void 0 ? void 0 : _d.toString()) || ""
        },
        deno: reflection.deno || false
    };
}
function readConfig(configPath, rootDir, config) {
    var _a, _b, _c, _d;
    const reflection = getConfigReflectionSection(configPath);
    const modes = Object.values(config_options_1.ModeValues);
    const metadataTypes = Object.values(config_options_1.MetadataTypeValues);
    if (!modes.includes(reflection.mode)) {
        throw new Error(`${helpers_1.PACKAGE_ID}: tsconfig.json error: "reflection.mode" must be one of ${modes.map(t => `"${t}"`)
            .join(", ")}`);
    }
    if (!metadataTypes.includes(reflection.metadata.type)) {
        throw new Error(`${helpers_1.PACKAGE_ID}: tsconfig.json error: "reflection.metadata.type" must be one of ${metadataTypes.map(t => `"${t}"`).join(", ")}`);
    }
    if (reflection.metadata.filePath.endsWith(".js")) {
        throw new Error(`${helpers_1.PACKAGE_ID}: tsconfig.json error: "reflection.metadata.filePath" must use the .ts extension. A .js version will be built to your projects out dir.`);
    }
    reflection.metadata.filePath = reflection.metadata.filePath ? (0, path_1.resolve)(rootDir, reflection.metadata.filePath) : (0, path_1.join)(rootDir, config_options_1.DEFAULT_METADATA_LIB_FILE_NAME);
    return {
        mode: (_a = config.mode) !== null && _a !== void 0 ? _a : reflection.mode,
        useMetadata: reflection.metadata.type !== config_options_1.MetadataTypeValues.inline,
        useMetadataType: reflection.metadata.type,
        metadataFilePath: reflection.metadata.filePath,
        debugMode: ["true", "1"].includes((_c = ((_b = config.debugMode) !== null && _b !== void 0 ? _b : reflection === null || reflection === void 0 ? void 0 : reflection.debugMode)) === null || _c === void 0 ? void 0 : _c.toString()),
        deno: (_d = config.deno) !== null && _d !== void 0 ? _d : reflection.deno
    };
}
function createConfig(options, rootDir, packageInfo, pluginConfig) {
    const rawConfigObject = options;
    const configPath = rawConfigObject.configFilePath;
    const config = readConfig(configPath, rootDir, pluginConfig);
    return {
        mode: config.mode,
        deno: config.deno,
        rootDir: packageInfo.rootDir,
        outDir: options.outDir || rootDir,
        tsConfigPath: configPath,
        esmModuleKind: isESMModule(options),
        moduleResolution: getModuleResolutionKind(options),
        projectDir: rootDir,
        packageName: packageInfo.name,
        useMetadata: config.useMetadata,
        useMetadataType: config.useMetadataType,
        metadataFilePath: config.metadataFilePath,
        debugMode: config.debugMode,
        parsedCommandLine: configPath && ts.getParsedCommandLineOfConfigFile(configPath, undefined, ts.sys),
        isUniversalMode() {
            return config.mode === config_options_1.ModeValues.universal;
        },
        isServerMode() {
            return config.mode === config_options_1.ModeValues.server;
        },
    };
}
exports.createConfig = createConfig;
function getModuleResolutionKind(options) {
    var _a, _b, _c, _d;
    return (_d = (_c = (_b = (_a = ts).getEmitModuleResolutionKind) === null || _b === void 0 ? void 0 : _b.call(_a, options)) !== null && _c !== void 0 ? _c : options.moduleResolution) !== null && _d !== void 0 ? _d : ts.ModuleResolutionKind.Classic;
}
function isESMModule(options) {
    const target = options.target || typescript_1.ScriptTarget.ES3;
    const module = options.module || ([typescript_1.ScriptTarget.ES3, typescript_1.ScriptTarget.ES5].includes(target) ? typescript_1.ModuleKind.CommonJS : typescript_1.ModuleKind.ES2015);
    return [typescript_1.ModuleKind.ES2015, typescript_1.ModuleKind.ES2020, typescript_1.ModuleKind.ES2022, typescript_1.ModuleKind.ESNext, typescript_1.ModuleKind.NodeNext].includes(module);
}
//# sourceMappingURL=config.js.map