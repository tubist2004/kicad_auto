"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processDecorator = void 0;
const ts = require("typescript");
const getGenericParametersDetails_1 = require("./getGenericParametersDetails");
const getTypeCall_1 = require("./getTypeCall");
const helpers_1 = require("./helpers");
const updateCallExpression_1 = require("./updateCallExpression");
function processDecorator(node, decoratorType, context) {
    const declaration = (0, helpers_1.getDeclaration)(decoratorType.symbol);
    if (!declaration) {
        return undefined;
    }
    const state = (0, getGenericParametersDetails_1.getGenericParametersDetails)(declaration, context, []);
    let genericTypeNode, genericType;
    if (ts.isPropertyDeclaration(node.parent) || ts.isMethodDeclaration(node.parent)) {
        genericTypeNode = node.parent.parent;
        genericType = context.typeChecker.getTypeAtLocation(genericTypeNode);
    }
    else {
        genericTypeNode = node.parent;
        genericType = context.typeChecker.getTypeAtLocation(genericTypeNode);
    }
    const genericTypeSymbol = genericType.getSymbol();
    if (!state || !state.usedGenericParameters || !state.indexesOfGenericParameters || !state.requestedGenericsReflection) {
        (0, getTypeCall_1.getTypeCall)(genericType, genericTypeSymbol, context, genericTypeNode.name);
        return undefined;
    }
    const genericParamName = state.usedGenericParameters[0];
    const typeArgumentDescription = {
        genericTypeName: genericParamName,
        reflectedType: (0, getTypeCall_1.getTypeCall)(genericType, genericTypeSymbol, context, genericTypeNode.name)
    };
    let callExpression;
    if (ts.isCallExpression(node.expression)) {
        callExpression = (0, updateCallExpression_1.updateCallExpression)(node.expression, state, [typeArgumentDescription]);
    }
    else if (ts.isIdentifier(node.expression)) {
        callExpression = createCallExpressionFromIdentifier(context, node, typeArgumentDescription);
    }
    else {
        return undefined;
    }
    (0, helpers_1.ignoreNode)(callExpression);
    return ts.factory.updateDecorator(node, callExpression);
}
exports.processDecorator = processDecorator;
function createCallExpressionFromIdentifier(context, node, typeArgumentDescription) {
    const argumentsIdentifier = ts.factory.createIdentifier("arguments");
    const callExpression = ts.factory.createCallExpression(node.expression, undefined, [
        ts.factory.createSpreadElement(argumentsIdentifier),
        ts.factory.createObjectLiteralExpression([ts.factory.createPropertyAssignment(typeArgumentDescription.genericTypeName, typeArgumentDescription.reflectedType)])
    ]);
    return ts.factory.createFunctionExpression(undefined, undefined, undefined, undefined, undefined, undefined, ts.factory.createBlock([
        ts.factory.createExpressionStatement(callExpression)
    ]));
}
//# sourceMappingURL=processDecorator.js.map