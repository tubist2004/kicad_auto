"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const getNodeLocationText_1 = require("../getNodeLocationText");
const helpers_1 = require("../helpers");
const getGenericParametersDetails_1 = require("../getGenericParametersDetails");
const log_1 = require("../log");
const InstanceKey = Symbol.for("tst-reflect.DeclarationVisitor");
let instance = global[InstanceKey] || null;
class DeclarationVisitor {
    static get instance() {
        if (!instance) {
            instance = Reflect.construct(DeclarationVisitor, [], Activator);
        }
        return instance;
    }
    visitDeclaration(node, context) {
        if ((ts.isMethodDeclaration(node) || ts.isFunctionDeclaration(node))) {
            if (node.body === undefined) {
                if (context.config.debugMode) {
                    log_1.log.info("Visiting declaration without body.");
                }
                return undefined;
            }
            const genericParametersDetails = (0, getGenericParametersDetails_1.getGenericParametersDetails)(node, context, []);
            if (!genericParametersDetails.usedGenericParameters) {
                return node;
            }
            return DeclarationVisitor.modifyDeclaration(node, context);
        }
        return node;
    }
    static modifyDeclaration(node, context) {
        const [modParams, modBody] = DeclarationVisitor.getModifiedDeclarationProperties(node.parameters, node.body, context);
        if (ts.isMethodDeclaration(node)) {
            return ts.factory.updateMethodDeclaration(node, node.decorators, node.modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, modParams, node.type, modBody);
        }
        return ts.factory.updateFunctionDeclaration(node, node.decorators, node.modifiers, node.asteriskToken, node.name, node.typeParameters, modParams, node.type, modBody);
    }
    static getModifiedDeclarationProperties(parameters, body, context) {
        const lastParam = parameters[parameters.length - 1];
        const argumentsIdentifier = ts.factory.createIdentifier("arguments");
        const argumentsLength = ts.factory.createPropertyAccessExpression(argumentsIdentifier, ts.factory.createIdentifier("length"));
        if (!lastParam || lastParam.dotDotDotToken === undefined) {
            return [
                parameters,
                ts.factory.createBlock([
                    ts.factory.createVariableStatement(undefined, [
                        ts.factory.createVariableDeclaration(helpers_1.GENERIC_PARAMS, undefined, undefined, ts.factory.createElementAccessExpression(argumentsIdentifier, ts.factory.createPrefixDecrement(argumentsLength)))
                    ]),
                    ts.factory.createExpressionStatement(ts.factory.createDeleteExpression(ts.factory.createElementAccessExpression(argumentsIdentifier, argumentsLength))),
                    ...body.statements
                ])
            ];
        }
        else if (ts.isIdentifier(lastParam.name)) {
            body = ts.factory.createBlock([
                ts.factory.createVariableStatement(undefined, [
                    ts.factory.createVariableDeclaration(helpers_1.GENERIC_PARAMS, undefined, undefined, ts.factory.createElementAccessExpression(ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(lastParam.name.escapedText.toString()), ts.factory.createIdentifier("splice")), undefined, [
                        ts.factory.createBinaryExpression(ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(lastParam.name.escapedText.toString()), ts.factory.createIdentifier("length")), ts.SyntaxKind.MinusToken, ts.factory.createNumericLiteral(1)),
                        ts.factory.createNumericLiteral(1)
                    ]), 0))
                ]),
                ts.factory.createExpressionStatement(ts.factory.createDeleteExpression(ts.factory.createElementAccessExpression(argumentsIdentifier, ts.factory.createPrefixDecrement(argumentsLength)))),
                ...body.statements
            ]);
            return [
                parameters,
                body
            ];
        }
        else if (ts.isArrayBindingPattern(lastParam.name)) {
            context.log.warn("ArrayBindingPattern not supported in generic declarations yet. At " + (0, getNodeLocationText_1.getNodeLocationText)(lastParam));
        }
        else if (ts.isObjectBindingPattern(lastParam.name)) {
            context.log.warn("ObjectBindingPattern not supported in generic declarations yet. At " + (0, getNodeLocationText_1.getNodeLocationText)(lastParam));
        }
        return [[...parameters], body];
    }
}
exports.default = DeclarationVisitor;
class Activator extends DeclarationVisitor {
}
//# sourceMappingURL=declarationVisitor.js.map