"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mainVisitor = void 0;
const tst_reflect_1 = require("tst-reflect");
const ts = require("typescript");
const helpers_1 = require("../helpers");
const log_1 = require("../log");
const processDecorator_1 = require("../processDecorator");
const processGenericCallExpression_1 = require("../processGenericCallExpression");
const processGetTypeCallExpression_1 = require("../processGetTypeCallExpression");
const declarationVisitor_1 = require("./declarationVisitor");
function mainVisitor(nodeToVisit, context) {
    var _a, _b, _c, _d, _e;
    const node = declarationVisitor_1.default.instance.visitDeclaration(nodeToVisit, context);
    const config = context.config;
    if (node === undefined) {
        return nodeToVisit;
    }
    if (ts.isCallExpression(node) && (!node.parent || !ts.isDecorator(node.parent))) {
        if ((0, helpers_1.isNodeIgnored)(node)) {
            return node;
        }
        if (ts.isIdentifier(node.expression) && node.expression.escapedText == tst_reflect_1.GET_TYPE_FNC_NAME) {
            const fncType = context.typeChecker.getTypeAtLocation(node.expression);
            if (fncType.getProperty(tst_reflect_1.TYPE_ID_PROPERTY_NAME) || ((context.config.deno || fncType.intrinsicName === "error") && ((_a = node.typeArguments) === null || _a === void 0 ? void 0 : _a.length) === 1)) {
                const res = (0, processGetTypeCallExpression_1.processGetTypeCallExpression)(node, context);
                if (res) {
                    return res;
                }
            }
        }
        else {
            let identifier = undefined;
            if (ts.isIdentifier(node.expression)) {
                identifier = node.expression;
            }
            else if (ts.isPropertyAccessExpression(node.expression)) {
                identifier = node.expression.name;
            }
            if (identifier !== undefined) {
                const type = context.typeChecker.getTypeAtLocation(identifier);
                if (((_b = node.typeArguments) === null || _b === void 0 ? void 0 : _b.length) || ((_e = (_d = (_c = type.getSymbol()) === null || _c === void 0 ? void 0 : _c.valueDeclaration) === null || _d === void 0 ? void 0 : _d.typeParameters) === null || _e === void 0 ? void 0 : _e.length)) {
                    const res = (0, processGenericCallExpression_1.processGenericCallExpression)(node, type, context);
                    if (res) {
                        return ts.visitEachChild(res, context.visitor, context.transformationContext);
                    }
                }
                else if (config.debugMode) {
                    log_1.log.info(`There is an callExpression '${identifier.escapedText}' but no declaration has been found.`);
                }
            }
        }
    }
    else if (ts.isDecorator(node) && (ts.isClassDeclaration(node.parent)
        || ts.isPropertyDeclaration(node.parent)
        || ts.isMethodDeclaration(node.parent)
        || ts.isGetAccessorDeclaration(node.parent)
        || ts.isSetAccessorDeclaration(node.parent))) {
        let type = undefined;
        if (ts.isCallExpression(node.expression)) {
            type = context.typeChecker.getTypeAtLocation(node.expression.expression);
        }
        else if (ts.isIdentifier(node.expression)) {
            const symbol = context.typeChecker.getSymbolAtLocation(node.expression);
            if (symbol) {
                type = (0, helpers_1.getType)(symbol, context.typeChecker);
            }
        }
        if (type && (0, helpers_1.hasReflectJsDoc)(type.getSymbol())) {
            const res = (0, processDecorator_1.processDecorator)(node, type, context);
            if (res) {
                return ts.visitEachChild(res, context.visitor, context.transformationContext);
            }
        }
    }
    else if (ts.isClassDeclaration(node)) {
        const typeId = (0, helpers_1.getTypeId)(context.typeChecker.getTypeAtLocation(node), context.typeChecker);
        if (typeId) {
            return [
                ts.visitEachChild(node, context.visitor, context.transformationContext),
                ts.factory.createExpressionStatement(ts.factory.createBinaryExpression(ts.factory.createElementAccessExpression(ts.factory.createPropertyAccessExpression(node.name, "prototype"), ts.factory.createStringLiteral(tst_reflect_1.REFLECTED_TYPE_ID)), ts.factory.createToken(ts.SyntaxKind.EqualsToken), ts.factory.createNumericLiteral(typeId)))
            ];
        }
    }
    return ts.visitEachChild(node, context.visitor, context.transformationContext);
}
exports.mainVisitor = mainVisitor;
//# sourceMappingURL=mainVisitor.js.map