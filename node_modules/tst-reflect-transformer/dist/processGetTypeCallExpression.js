"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processGetTypeCallExpression = void 0;
const ts = require("typescript");
const getTypeCall_1 = require("./getTypeCall");
const helpers_1 = require("./helpers");
function processGetTypeCallExpression(node, context) {
    var _a;
    let genericTypeNode = (_a = node.typeArguments) === null || _a === void 0 ? void 0 : _a[0];
    if (!genericTypeNode) {
        return undefined;
    }
    let genericType = context.typeChecker.getTypeAtLocation(genericTypeNode);
    if (genericType.flags == ts.TypeFlags.TypeParameter) {
        if (ts.isTypeReferenceNode(genericTypeNode) && ts.isIdentifier(genericTypeNode.typeName)) {
            return ts.factory.createParenthesizedExpression(ts.factory.createBinaryExpression(ts.factory.createIdentifier(helpers_1.GENERIC_PARAMS), ts.SyntaxKind.AmpersandAmpersandToken, ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(helpers_1.GENERIC_PARAMS), ts.factory.createIdentifier(genericTypeNode.typeName.escapedText.toString()))));
        }
        return undefined;
    }
    else {
        return (0, getTypeCall_1.getTypeCall)(genericType, undefined, context, ts.isTypeReferenceNode(genericTypeNode) ? genericTypeNode.typeName : undefined);
    }
}
exports.processGetTypeCallExpression = processGetTypeCallExpression;
//# sourceMappingURL=processGetTypeCallExpression.js.map