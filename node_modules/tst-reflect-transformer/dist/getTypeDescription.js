"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTypeDescription = void 0;
const tst_reflect_1 = require("tst-reflect");
const ts = require("typescript");
const config_options_1 = require("./config-options");
const getConstructors_1 = require("./getConstructors");
const getDecorators_1 = require("./getDecorators");
const getExports_1 = require("./getExports");
const getIndexes_1 = require("./getIndexes");
const getLiteralName_1 = require("./getLiteralName");
const getMethods_1 = require("./getMethods");
const getNativeTypeDescription_1 = require("./getNativeTypeDescription");
const getNodeLocationText_1 = require("./getNodeLocationText");
const getProperties_1 = require("./getProperties");
const getSignatureParameters_1 = require("./getSignatureParameters");
const getTypeCall_1 = require("./getTypeCall");
const helpers_1 = require("./helpers");
const log_1 = require("./log");
const NodeGenerator_1 = require("./NodeGenerator");
function getTypeDescription(type, symbol, context, typeCtor) {
    var _a, _b, _c, _d, _e;
    if (context.config.debugMode && (symbol === null || symbol === void 0 ? void 0 : symbol.declarations)) {
        log_1.log.trace((0, getNodeLocationText_1.getNodeLocationText)(symbol.declarations[0]));
    }
    const nativeTypeDescriptionResult = (0, getNativeTypeDescription_1.getNativeTypeDescription)(type, context);
    if (nativeTypeDescriptionResult.ok) {
        return {
            properties: nativeTypeDescriptionResult.typeDescription,
            localType: false
        };
    }
    let typeSymbol = type.getSymbol();
    if (type.aliasSymbol) {
        symbol = type.aliasSymbol;
    }
    if (!symbol && typeSymbol) {
        symbol = typeSymbol;
    }
    if (type.isUnion() && (type.flags & ts.TypeFlags.EnumLiteral) == ts.TypeFlags.EnumLiteral) {
        return {
            properties: {
                k: tst_reflect_1.TypeKind.Enum,
                n: symbol === null || symbol === void 0 ? void 0 : symbol.escapedName.toString(),
                types: type.types.map(type => (0, getTypeCall_1.getTypeCall)(type, undefined, context)),
            },
            localType: false
        };
    }
    if ((type.flags & ts.TypeFlags.Literal) != 0) {
        return {
            properties: {
                k: tst_reflect_1.TypeKind.LiteralType,
                n: (0, getLiteralName_1.default)(type),
                v: type.value,
            },
            localType: false
        };
    }
    const checker = context.typeChecker;
    if (type.isUnionOrIntersection()) {
        let types;
        if (type.isUnion()) {
            types = (0, helpers_1.simplifyUnionWithTrueFalse)(type, context);
        }
        else {
            types = type.types
                .map(childType => (0, getTypeCall_1.getTypeCall)(childType, undefined, context));
        }
        return {
            properties: {
                n: symbol === null || symbol === void 0 ? void 0 : symbol.escapedName.toString(),
                k: tst_reflect_1.TypeKind.Container,
                types: types,
                union: type.isUnion(),
                inter: type.isIntersection()
            },
            localType: false
        };
    }
    if (symbol) {
        if (symbol.flags == ts.SymbolFlags.TypeLiteral && type.flags == ts.TypeFlags.Object) {
            if (context.config.debugMode) {
                log_1.log.info("Symbol is TypeLiteral of Object type.");
            }
            const declaration = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a[0];
            if (declaration && ts.isTypeLiteralNode(declaration) && type.aliasSymbol) {
                return {
                    properties: {
                        k: tst_reflect_1.TypeKind.Object,
                        n: type.aliasSymbol.name,
                        fn: (0, helpers_1.getTypeFullName)(type, context),
                        props: (0, getProperties_1.getProperties)(symbol, type, context),
                        indxs: (0, getIndexes_1.getIndexes)(type, context)
                    },
                    localType: false
                };
            }
            return {
                properties: {
                    k: tst_reflect_1.TypeKind.Object,
                    props: (0, getProperties_1.getProperties)(symbol, type, context),
                    indxs: (0, getIndexes_1.getIndexes)(type, context)
                },
                localType: false
            };
        }
        if (symbol.valueDeclaration && (ts.isPropertyDeclaration(symbol.valueDeclaration)
            || ts.isPropertySignature(symbol.valueDeclaration)
            || ts.isVariableDeclaration(symbol.valueDeclaration)
            || ts.isParameter(symbol.valueDeclaration))) {
            if (symbol.valueDeclaration.type) {
                if (ts.isTypeReferenceNode(symbol.valueDeclaration.type)
                    && typeSymbol && (typeSymbol.flags & ts.SymbolFlags.Transient) == ts.SymbolFlags.Transient) {
                    return {
                        properties: {
                            k: tst_reflect_1.TypeKind.TransientTypeReference,
                            n: symbol.valueDeclaration.type.typeName.escapedText,
                            args: ((_b = symbol.valueDeclaration.type.typeArguments) === null || _b === void 0 ? void 0 : _b.map(typeNode => (0, getTypeCall_1.getTypeCall)(checker.getTypeAtLocation(typeNode), checker.getSymbolAtLocation(typeNode), context))) || [],
                        },
                        localType: false
                    };
                }
                let isUnion, isIntersection = false;
                if ((isUnion = ts.isUnionTypeNode(symbol.valueDeclaration.type))
                    || (isIntersection = ts.isIntersectionTypeNode(symbol.valueDeclaration.type))) {
                    const types = symbol.valueDeclaration.type.types
                        .map(typeNode => (0, getTypeCall_1.getTypeCall)(checker.getTypeAtLocation(typeNode), checker.getSymbolAtLocation(typeNode), context));
                    return {
                        properties: {
                            n: symbol.escapedName.toString(),
                            k: tst_reflect_1.TypeKind.Container,
                            types: types,
                            union: isUnion,
                            inter: isIntersection
                        },
                        localType: false
                    };
                }
            }
        }
    }
    if (!typeSymbol) {
        if (context.config.debugMode) {
            log_1.log.info("'typeSymbol' is undefined.");
        }
        if (type.flags & ts.TypeFlags.Object) {
            if (context.config.debugMode) {
                log_1.log.info("Symbol is TypeLiteral of Object type.");
            }
            return {
                properties: {
                    k: tst_reflect_1.TypeKind.Object,
                    props: (0, getProperties_1.getProperties)(symbol, type, context),
                    indxs: (0, getIndexes_1.getIndexes)(type, context)
                },
                localType: false
            };
        }
        else if ((type.flags & ts.TypeFlags.Conditional) == ts.TypeFlags.Conditional) {
            const ct = type.root.node;
            const extendsType = checker.getTypeAtLocation(ct.extendsType);
            const trueType = checker.getTypeAtLocation(ct.trueType);
            return {
                properties: {
                    k: tst_reflect_1.TypeKind.ConditionalType,
                    ct: {
                        e: (0, getTypeCall_1.getTypeCall)(extendsType, extendsType.symbol, context),
                        tt: (0, getTypeCall_1.getTypeCall)(trueType, trueType.symbol, context),
                        ft: (0, getTypeCall_1.getTypeCall)(checker.getTypeAtLocation(ct.falseType), checker.getSymbolAtLocation(ct.falseType), context)
                    }
                },
                localType: false
            };
        }
        else if ((type.flags & ts.TypeFlags.IndexedAccess) == ts.TypeFlags.IndexedAccess) {
            const indexedAccess = type;
            return {
                properties: {
                    k: tst_reflect_1.TypeKind.IndexedAccess,
                    iat: {
                        ot: (0, getTypeCall_1.getTypeCall)(indexedAccess.objectType, indexedAccess.objectType.symbol, context),
                        it: (0, getTypeCall_1.getTypeCall)(indexedAccess.indexType, indexedAccess.indexType.symbol, context)
                    }
                },
                localType: false
            };
        }
        log_1.log.warn("Unable to resolve type's symbol. Returning type Unknown.");
        return { properties: helpers_1.UNKNOWN_TYPE_PROPERTIES, localType: false };
    }
    else if ((type.flags & ts.TypeFlags.Object) == ts.TypeFlags.Object && (typeSymbol.flags & ts.SymbolFlags.TypeLiteral) == ts.SymbolFlags.TypeLiteral) {
        if (context.config.debugMode) {
            log_1.log.info("'typeSymbol' is TypeLiteral.");
        }
        return {
            properties: {
                n: (_c = type.aliasSymbol) === null || _c === void 0 ? void 0 : _c.name.toString(),
                k: tst_reflect_1.TypeKind.Object,
                props: (0, getProperties_1.getProperties)(typeSymbol, type, context),
                indxs: (0, getIndexes_1.getIndexes)(type, context)
            },
            localType: false
        };
    }
    else if ((type.flags & ts.TypeFlags.Object) == ts.TypeFlags.Object && (typeSymbol.flags & ts.SymbolFlags.ObjectLiteral) == ts.SymbolFlags.ObjectLiteral) {
        if (context.config.debugMode) {
            log_1.log.info("'typeSymbol' is ObjectLiteral.");
        }
        return {
            properties: {
                k: tst_reflect_1.TypeKind.Object,
                props: (0, getProperties_1.getProperties)(typeSymbol, type, context),
                indxs: (0, getIndexes_1.getIndexes)(type, context)
            },
            localType: false
        };
    }
    else if ((type.flags & ts.TypeFlags.TypeParameter) == ts.TypeFlags.TypeParameter && (typeSymbol.flags & ts.SymbolFlags.TypeParameter) == ts.SymbolFlags.TypeParameter) {
        if (context.config.debugMode) {
            log_1.log.info("'typeSymbol' is TypeParameter.");
        }
        if (typeSymbol.declarations) {
            const typeParameter = typeSymbol.declarations[0];
            if (ts.isTypeParameterDeclaration(typeParameter)) {
                return {
                    properties: {
                        k: tst_reflect_1.TypeKind.TypeParameter,
                        n: typeParameter.name.escapedText,
                        con: typeParameter.constraint && (0, getTypeCall_1.getTypeCall)(checker.getTypeAtLocation(typeParameter.constraint), checker.getSymbolAtLocation(typeParameter.constraint), context) || undefined,
                        def: typeParameter.default && (0, getTypeCall_1.getTypeCall)(checker.getTypeAtLocation(typeParameter.default), checker.getSymbolAtLocation(typeParameter.default), context) || undefined
                    },
                    localType: false
                };
            }
        }
        context.log.warn("Unable to resolve TypeParameter's declaration.");
        return { properties: helpers_1.UNKNOWN_TYPE_PROPERTIES, localType: false };
    }
    else if ((typeSymbol.flags & ts.SymbolFlags.Function) !== 0) {
        return {
            properties: {
                k: tst_reflect_1.TypeKind.Function,
                n: typeSymbol.getName(),
                fn: (0, helpers_1.getTypeFullName)(type, context),
                sg: type.getCallSignatures().map(signature => {
                    var _a;
                    const returnType = signature.getReturnType();
                    return ({
                        params: (0, getSignatureParameters_1.getSignatureParameters)(signature, context),
                        rt: (0, getTypeCall_1.getTypeCall)(returnType, returnType.symbol, context) || (0, helpers_1.getUnknownTypeCall)(context),
                        tp: (_a = signature.getTypeParameters()) === null || _a === void 0 ? void 0 : _a.map(typeParameter => (0, getTypeCall_1.getTypeCall)(typeParameter, typeParameter.symbol, context))
                    });
                })
            },
            localType: false
        };
    }
    else if ((typeSymbol.flags & ts.SymbolFlags.Method) !== 0) {
        return {
            properties: {
                k: tst_reflect_1.TypeKind.Method,
                n: typeSymbol.getName(),
                fn: (0, helpers_1.getTypeFullName)(type, context),
                sg: type.getCallSignatures().map(signature => {
                    var _a;
                    const returnType = signature.getReturnType();
                    return ({
                        params: (0, getSignatureParameters_1.getSignatureParameters)(signature, context),
                        rt: (0, getTypeCall_1.getTypeCall)(returnType, returnType.symbol, context) || (0, helpers_1.getUnknownTypeCall)(context),
                        tp: (_a = signature.getTypeParameters()) === null || _a === void 0 ? void 0 : _a.map(typeParameter => (0, getTypeCall_1.getTypeCall)(typeParameter, typeParameter.symbol, context))
                    });
                })
            },
            localType: false
        };
    }
    const kind = (0, helpers_1.getTypeKind)(typeSymbol);
    if (kind == null) {
        return { properties: helpers_1.UNKNOWN_TYPE_PROPERTIES, localType: false };
    }
    const decorators = (0, getDecorators_1.getDecorators)(typeSymbol, context);
    const symbolToUse = typeSymbol || symbol;
    let localType = false;
    const typeArgs = context.typeChecker.getTypeArguments(type);
    const isGenericType = (((_d = type.objectFlags) !== null && _d !== void 0 ? _d : 0) & ts.ObjectFlags.Reference) !== 0 && typeArgs.length !== 0;
    const properties = {
        k: kind,
        isg: isGenericType,
        gtd: isGenericType && type !== type.target ? (0, getTypeCall_1.getTypeCall)(type.target, undefined, context, typeCtor) : undefined,
        n: typeSymbol.getName(),
        fn: (0, helpers_1.getTypeFullName)(type, context),
        props: (0, getProperties_1.getProperties)(symbolToUse, type, context),
        indxs: (0, getIndexes_1.getIndexes)(type, context),
        meths: (0, getMethods_1.getMethods)(symbolToUse, type, context),
        decs: decorators,
        args: typeArgs.map(t => (0, getTypeCall_1.getTypeCall)(t, undefined, context))
    };
    if (kind === tst_reflect_1.TypeKind.Class) {
        const symbolType = (0, helpers_1.getType)(typeSymbol, checker);
        if (symbolType === undefined) {
            const declaration = (0, helpers_1.getDeclaration)(symbolType);
            context.log.warn("Unable to resolve ts.Type of the symbol." + (declaration === undefined ? "" : " At " + (0, getNodeLocationText_1.getNodeLocationText)(declaration)));
        }
        else {
            properties.ctors = (0, getConstructors_1.getConstructors)(symbolType, context);
        }
        if (typeCtor) {
            const constructorExport = (0, getExports_1.getExportOfConstructor)(typeSymbol, typeCtor, context);
            if (constructorExport) {
                if (context.config.isServerMode()) {
                    properties.ctorDesc = NodeGenerator_1.nodeGenerator.createObjectLiteralExpressionNode(constructorExport);
                }
                const [ctorGetter, ctorRequireCall] = (0, helpers_1.createCtorPromise)(typeCtor, constructorExport, context);
                if (ctorGetter) {
                    properties.ctor = ctorGetter;
                    if (ctorRequireCall) {
                        context.addTypeCtor(ctorRequireCall);
                    }
                }
            }
            else {
                localType = true;
                let expression = typeCtor;
                if (context.config.useMetadataType == config_options_1.MetadataTypeValues.typeLib) {
                    expression = ts.factory.createConditionalExpression(ts.factory.createBinaryExpression(ts.factory.createTypeOfExpression(expression), ts.factory.createToken(ts.SyntaxKind.EqualsEqualsToken), ts.factory.createStringLiteral("function")), ts.factory.createToken(ts.SyntaxKind.QuestionToken), expression, ts.factory.createToken(ts.SyntaxKind.ColonToken), ts.factory.createIdentifier("undefined"));
                }
                properties.ctor = ts.factory.createFunctionExpression(undefined, undefined, undefined, undefined, [], undefined, ts.factory.createBlock([
                    ts.factory.createReturnStatement(ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier("Promise"), ts.factory.createIdentifier("resolve")), undefined, [
                        expression
                    ]))
                ], true));
            }
        }
    }
    const declaration = (_e = typeSymbol.declarations) === null || _e === void 0 ? void 0 : _e[0];
    if (declaration && (ts.isClassDeclaration(declaration) || ts.isInterfaceDeclaration(declaration))) {
        if (declaration.heritageClauses) {
            const ext = declaration.heritageClauses.filter(h => h.token == ts.SyntaxKind.ExtendsKeyword)[0];
            if (ext) {
                properties.bt = (0, getTypeCall_1.getTypeCall)(checker.getTypeAtLocation(ext.types[0]), checker.getSymbolAtLocation(ext.types[0]), context);
            }
            const impl = declaration.heritageClauses.filter(h => h.token == ts.SyntaxKind.ImplementsKeyword)[0];
            if (impl) {
                properties.iface = (0, getTypeCall_1.getTypeCall)(checker.getTypeAtLocation(impl.types[0]), checker.getSymbolAtLocation(impl.types[0]), context);
            }
        }
        if (declaration.typeParameters) {
            properties.tp = declaration.typeParameters.map(typeParameterDeclaration => (0, getTypeCall_1.getTypeCall)(checker.getTypeAtLocation(typeParameterDeclaration), checker.getSymbolAtLocation(typeParameterDeclaration), context));
        }
    }
    return {
        properties: properties,
        localType: localType
    };
}
exports.getTypeDescription = getTypeDescription;
//# sourceMappingURL=getTypeDescription.js.map