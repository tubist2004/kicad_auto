"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.simplifyUnionWithTrueFalse = exports.ignoreNode = exports.isNodeIgnored = exports.getCtorTypeReference = exports.isTypedDeclaration = exports.replaceExtension = exports.getOutPathForSourceFile = exports.getRequireRelativePath = exports.isTsNode = exports.getFunctionLikeSignature = exports.getBooleanTypeCall = exports.getUnknownTypeCall = exports.isReadonly = exports.getAccessor = exports.getAccessModifier = exports.createCtorPromise = exports.getProjectSrcRoot = exports.hasRuntimePackageImport = exports.getSourceFileImports = exports.hasTraceJsDoc = exports.hasReflectJsDoc = exports.isExpression = exports.getTypeFullName = exports.getSymbol = exports.getTypeKind = exports.getDeclaration = exports.getTypeId = exports.isPromiseType = exports.isArrayType = exports.getTypeSymbol = exports.getType = exports.BOOLEAN_TYPE_PROPERTIES = exports.UNKNOWN_TYPE_PROPERTIES = exports.TRACE_DECORATOR = exports.PACKAGE_ID = exports.GENERIC_PARAMS = exports.PATH_SEPARATOR_REGEX = void 0;
const path = require("path");
const tst_reflect_1 = require("tst-reflect");
const ts = require("typescript");
const TransformerContext_1 = require("./contexts/TransformerContext");
const getTypeCall_1 = require("./getTypeCall");
const log_1 = require("./log");
exports.PATH_SEPARATOR_REGEX = /\\/g;
exports.GENERIC_PARAMS = "__genericParams__";
exports.PACKAGE_ID = "tst-reflect-transformer";
exports.TRACE_DECORATOR = "trace";
exports.UNKNOWN_TYPE_PROPERTIES = { n: "unknown", k: tst_reflect_1.TypeKind.Native };
let unknownTypeCallExpression = undefined;
exports.BOOLEAN_TYPE_PROPERTIES = { n: "Boolean", k: tst_reflect_1.TypeKind.Native };
let booleanTypeCallExpression = undefined;
function getType(symbol, checker) {
    if (symbol.flags == ts.SymbolFlags.Interface) {
        return checker.getDeclaredTypeOfSymbol(symbol);
    }
    const declaration = getDeclaration(symbol);
    if (!declaration) {
        return undefined;
    }
    return checker.getTypeOfSymbolAtLocation(symbol, declaration);
}
exports.getType = getType;
function getTypeSymbol(type, typeChecker) {
    const symbol = type.aliasSymbol || type.symbol;
    if (symbol) {
        return (symbol.flags & ts.SymbolFlags.Alias) ? typeChecker.getAliasedSymbol(symbol) : symbol;
    }
    return undefined;
}
exports.getTypeSymbol = getTypeSymbol;
function isArrayType(type) {
    var _a;
    return !!(type.flags & ts.TypeFlags.Object) && ((_a = type.symbol) === null || _a === void 0 ? void 0 : _a.escapedName) == "Array";
}
exports.isArrayType = isArrayType;
function isPromiseType(type) {
    var _a;
    return !!(type.flags & ts.TypeFlags.Object) && ((_a = type.symbol) === null || _a === void 0 ? void 0 : _a.escapedName) == "Promise";
}
exports.isPromiseType = isPromiseType;
let typeIdCounter = -1;
function getTypeId(type, typeChecker) {
    var _a;
    return (_a = type.id) !== null && _a !== void 0 ? _a : (type.id = typeIdCounter--);
}
exports.getTypeId = getTypeId;
function getDeclaration(symbol) {
    var _a;
    if (!symbol) {
        return undefined;
    }
    return symbol.valueDeclaration || ((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a[0]);
}
exports.getDeclaration = getDeclaration;
function getTypeKind(symbol) {
    if ((symbol.flags & ts.SymbolFlags.Class) !== 0) {
        return tst_reflect_1.TypeKind.Class;
    }
    if ((symbol.flags & ts.SymbolFlags.Interface) !== 0) {
        return tst_reflect_1.TypeKind.Interface;
    }
    if ((symbol.flags & ts.SymbolFlags.Module) !== 0) {
        return tst_reflect_1.TypeKind.Module;
    }
    if ((symbol.flags & ts.SymbolFlags.Method) !== 0) {
        return tst_reflect_1.TypeKind.Method;
    }
    if ((symbol.flags & ts.SymbolFlags.RegularEnum) !== 0) {
        return tst_reflect_1.TypeKind.Enum;
    }
    return null;
}
exports.getTypeKind = getTypeKind;
const nodeModulesPattern = "/node_modules/";
function getSymbol(type) {
    return type.aliasSymbol || type.symbol;
}
exports.getSymbol = getSymbol;
function getTypeFullName(type, context) {
    const symbol = getSymbol(type);
    const declaration = getDeclaration(symbol);
    if (!declaration) {
        if (context.config.debugMode) {
            context.log.error("Unable to get fullname of type, because its symbol is undefined.");
        }
        return undefined;
    }
    let { packageName, rootDir } = TransformerContext_1.default.instance.config;
    let filePath = declaration.getSourceFile().fileName;
    const nodeModulesIndex = filePath.lastIndexOf(nodeModulesPattern);
    if (nodeModulesIndex != -1) {
        filePath = filePath.slice(nodeModulesIndex + nodeModulesPattern.length);
    }
    else if (rootDir) {
        filePath = packageName + "/" + path.relative(rootDir, filePath).replace(exports.PATH_SEPARATOR_REGEX, "/");
    }
    return filePath + ":" + symbol.getName() + "#" + getTypeId(type, context.typeChecker);
}
exports.getTypeFullName = getTypeFullName;
function isExpression(value) {
    return value.hasOwnProperty("kind") && (value.constructor.name == "NodeObject" || value.constructor.name == "IdentifierObject" || value.constructor.name == "TokenObject");
}
exports.isExpression = isExpression;
function hasReflectJsDoc(symbol) {
    if (!symbol) {
        return false;
    }
    return symbol.getJsDocTags().some(tag => tag.name === tst_reflect_1.REFLECT_DECORATOR);
}
exports.hasReflectJsDoc = hasReflectJsDoc;
function hasTraceJsDoc(fncType) {
    const symbol = fncType.getSymbol();
    if (!symbol) {
        return false;
    }
    return symbol.getJsDocTags().some(tag => tag.name === exports.TRACE_DECORATOR);
}
exports.hasTraceJsDoc = hasTraceJsDoc;
function getSourceFileImports(sourceFile) {
    return sourceFile.statements.filter(st => ts.isImportDeclaration(st));
}
exports.getSourceFileImports = getSourceFileImports;
function hasRuntimePackageImport(sourceFile) {
    var _a, _b;
    const imports = getSourceFileImports(sourceFile);
    if (!(imports === null || imports === void 0 ? void 0 : imports.length)) {
        return [false, [], -1];
    }
    let getTypeNodePosition = -1;
    let isImported = false;
    const namedImports = [];
    for (let fileImp of imports) {
        if (((_b = (_a = fileImp === null || fileImp === void 0 ? void 0 : fileImp.moduleSpecifier) === null || _a === void 0 ? void 0 : _a.text) === null || _b === void 0 ? void 0 : _b.toString()) !== "tst-reflect") {
            continue;
        }
        isImported = true;
        const clause = fileImp.importClause;
        if (!ts.isImportClause(clause) || (clause === null || clause === void 0 ? void 0 : clause.namedBindings) === undefined) {
            continue;
        }
        const bindings = clause === null || clause === void 0 ? void 0 : clause.namedBindings;
        if (!ts.isNamedImports(bindings)) {
            continue;
        }
        bindings.elements.forEach(e => {
            var _a, _b;
            if (!((_b = (_a = e === null || e === void 0 ? void 0 : e.name) === null || _a === void 0 ? void 0 : _a.text) === null || _b === void 0 ? void 0 : _b.toString()) || namedImports.includes(e.name.text.toString())) {
                return;
            }
            if (e.name.text.toString() === "getType") {
                getTypeNodePosition = fileImp.pos;
            }
            namedImports.push(e.name.text.toString());
        });
    }
    return [isImported, namedImports, getTypeNodePosition];
}
exports.hasRuntimePackageImport = hasRuntimePackageImport;
function getProjectSrcRoot(program) {
    var _a;
    return path.resolve(((_a = program.getCompilerOptions()) === null || _a === void 0 ? void 0 : _a.rootDir) || program.getCurrentDirectory());
}
exports.getProjectSrcRoot = getProjectSrcRoot;
function createCtorPromise(typeCtor, constructorDescription, context) {
    if (!constructorDescription) {
        return [undefined, undefined];
    }
    let relative = context.metaWriter.getRequireRelativePath(context, constructorDescription.srcPath);
    if (context.config.debugMode) {
        log_1.log.info(`Relative import for source file(${context.currentSourceFile.fileName}) is: ${relative}`);
    }
    if (context.config.esmModuleKind) {
        const importExpression = ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(ts.factory.createCallExpression(ts.factory.createIdentifier("import"), undefined, [
            ts.factory.createStringLiteral(relative)
        ]), "then"), undefined, [
            ts.factory.createArrowFunction(undefined, undefined, [
                ts.factory.createParameterDeclaration(undefined, undefined, undefined, "m")
            ], undefined, ts.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken), ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier("m"), ts.factory.createIdentifier(constructorDescription.en)))
        ]);
        return [
            ts.factory.createFunctionExpression(undefined, undefined, undefined, undefined, [], undefined, ts.factory.createBlock([ts.factory.createReturnStatement(importExpression)], true)),
            undefined
        ];
    }
    const requireCall = ts.factory.createPropertyAccessExpression(ts.factory.createCallExpression(ts.factory.createIdentifier("require"), undefined, [ts.factory.createStringLiteral(relative)]), ts.factory.createIdentifier(constructorDescription.en));
    const promise = ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier("Promise"), ts.factory.createIdentifier("resolve")), undefined, [
        requireCall
    ]);
    const functionCall = ts.factory.createFunctionExpression(undefined, undefined, undefined, undefined, [], undefined, ts.factory.createBlock([ts.factory.createReturnStatement(promise)], true));
    return [functionCall, requireCall];
}
exports.createCtorPromise = createCtorPromise;
function getAccessModifier(modifiers) {
    var _a;
    const kinds = (_a = modifiers === null || modifiers === void 0 ? void 0 : modifiers.map(m => m.kind)) !== null && _a !== void 0 ? _a : [];
    if (kinds.includes(ts.SyntaxKind.PrivateKeyword)) {
        return tst_reflect_1.AccessModifier.Private;
    }
    if (kinds.includes(ts.SyntaxKind.ProtectedKeyword)) {
        return tst_reflect_1.AccessModifier.Protected;
    }
    return tst_reflect_1.AccessModifier.Public;
}
exports.getAccessModifier = getAccessModifier;
function getAccessor(node) {
    if (node != undefined) {
        if (node.kind == ts.SyntaxKind.GetAccessor) {
            return tst_reflect_1.Accessor.Getter;
        }
        if (node.kind == ts.SyntaxKind.SetAccessor) {
            return tst_reflect_1.Accessor.Setter;
        }
    }
    return tst_reflect_1.Accessor.None;
}
exports.getAccessor = getAccessor;
function isReadonly(modifiers) {
    var _a;
    return (_a = modifiers === null || modifiers === void 0 ? void 0 : modifiers.some(m => m.kind == ts.SyntaxKind.ReadonlyKeyword)) !== null && _a !== void 0 ? _a : false;
}
exports.isReadonly = isReadonly;
function getUnknownTypeCall(context) {
    return unknownTypeCallExpression || (unknownTypeCallExpression = (0, getTypeCall_1.getTypeCallFromProperties)(exports.UNKNOWN_TYPE_PROPERTIES, context));
}
exports.getUnknownTypeCall = getUnknownTypeCall;
function getBooleanTypeCall(context) {
    return booleanTypeCallExpression || (booleanTypeCallExpression = (0, getTypeCall_1.getTypeCallFromProperties)(exports.BOOLEAN_TYPE_PROPERTIES, context));
}
exports.getBooleanTypeCall = getBooleanTypeCall;
function getFunctionLikeSignature(symbol, declaration, checker) {
    var _a;
    declaration !== null && declaration !== void 0 ? declaration : (declaration = getDeclaration(symbol));
    if (declaration && (ts.isMethodSignature(declaration) || ts.isMethodDeclaration(declaration))) {
        return checker.getSignatureFromDeclaration(declaration);
    }
    const type = getType(symbol, checker);
    if (type === undefined) {
        return type;
    }
    return (_a = checker.getSignaturesOfType(type, ts.SignatureKind.Call)) === null || _a === void 0 ? void 0 : _a[0];
}
exports.getFunctionLikeSignature = getFunctionLikeSignature;
function isTsNode() {
    const lastArg = process.execArgv[process.execArgv.length - 1];
    if (lastArg && path.parse(lastArg).name.indexOf("ts-node") >= 0) {
        return true;
    }
    try {
        const isTsNode = process[Symbol.for("ts-node.register.instance")];
        return (isTsNode === null || isTsNode === void 0 ? void 0 : isTsNode.ts) !== undefined;
    }
    catch (error) {
        console.error(error);
    }
    return false;
}
exports.isTsNode = isTsNode;
function getRequireRelativePath(sourceFileDefiningImport, sourceFileImporting) {
    const filePath = replaceExtension("./" + path.relative(path.dirname(sourceFileDefiningImport), sourceFileImporting), "");
    if (TransformerContext_1.default.instance.config.moduleResolution === ts.ModuleResolutionKind.Node16
        || TransformerContext_1.default.instance.config.moduleResolution === ts.ModuleResolutionKind.NodeNext) {
        const ext = path.extname(sourceFileImporting);
        if (ext === ".ts") {
            return filePath + ".js";
        }
        if (ext === ".tsx") {
            return filePath + ".jsx";
        }
        if (ext === ".mts") {
            return filePath + ".mjs";
        }
    }
    return filePath;
}
exports.getRequireRelativePath = getRequireRelativePath;
function getOutPathForSourceFile(sourceFileName, context, useTsNode = true) {
    if (useTsNode && isTsNode()) {
        return sourceFileName;
    }
    if (context.config.parsedCommandLine) {
        if (!context.config.parsedCommandLine.fileNames.includes(sourceFileName)) {
            context.config.parsedCommandLine.fileNames.push(sourceFileName);
        }
        return ts.getOutputFileNames(context.config.parsedCommandLine, sourceFileName, false)
            .filter(fn => fn.slice(-3) == ".js" || fn.slice(-4) == ".jsx" || fn.slice(-5) == ".d.ts")[0];
    }
    let outPath = sourceFileName.replace(context.config.rootDir, "");
    if (outPath.startsWith("/")) {
        outPath = outPath.slice(1);
    }
    outPath = path.join(context.config.outDir, outPath);
    return replaceExtension(outPath, ".js");
}
exports.getOutPathForSourceFile = getOutPathForSourceFile;
function replaceExtension(fileName, replaceWith) {
    const extName = path.extname(fileName);
    if (fileName.endsWith(extName)) {
        fileName = fileName.slice(0, fileName.length - extName.length) + replaceWith;
    }
    return fileName.replace(exports.PATH_SEPARATOR_REGEX, "/");
}
exports.replaceExtension = replaceExtension;
function isTypedDeclaration(declaration) {
    return !!(declaration === null || declaration === void 0 ? void 0 : declaration.type);
}
exports.isTypedDeclaration = isTypedDeclaration;
function getCtorTypeReference(symbol) {
    const declaration = getDeclaration(symbol);
    if (!declaration) {
        return undefined;
    }
    if (isTypedDeclaration(declaration)) {
        let typeName = undefined;
        if (ts.isIndexedAccessTypeNode(declaration.type)) {
            typeName = declaration.type.indexType.typeName;
        }
        else {
            typeName = declaration.type.typeName;
        }
        if (typeName && (typeName === null || typeName === void 0 ? void 0 : typeName.kind) === ts.SyntaxKind.Identifier) {
            return typeName;
        }
    }
    return undefined;
}
exports.getCtorTypeReference = getCtorTypeReference;
const IGNORE_PROPERTY_NAME = "__ignore-node-reflection";
function isNodeIgnored(node) {
    return node.pos == -1 || node[IGNORE_PROPERTY_NAME];
}
exports.isNodeIgnored = isNodeIgnored;
function ignoreNode(node) {
    node[IGNORE_PROPERTY_NAME] = true;
}
exports.ignoreNode = ignoreNode;
function simplifyUnionWithTrueFalse(type, context) {
    const types = [];
    let trueType = undefined, falseType = undefined;
    for (let i = 0; i < type.types.length; i++) {
        const childType = type.types[i];
        if ((childType.flags & ts.TypeFlags.BooleanLiteral) !== 0) {
            if (childType.intrinsicName === "true") {
                trueType = childType;
            }
            else {
                falseType = childType;
            }
        }
        else {
            types.push((0, getTypeCall_1.getTypeCall)(childType, undefined, context));
        }
    }
    if (trueType && falseType) {
        types.push(getBooleanTypeCall(context));
    }
    else if (trueType) {
        types.push((0, getTypeCall_1.getTypeCall)(trueType, undefined, context));
    }
    else if (falseType) {
        types.push((0, getTypeCall_1.getTypeCall)(falseType, undefined, context));
    }
    return types;
}
exports.simplifyUnionWithTrueFalse = simplifyUnionWithTrueFalse;
//# sourceMappingURL=helpers.js.map