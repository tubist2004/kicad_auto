"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGenericParametersDetails = void 0;
const ts = require("typescript");
const FunctionLikeDeclarationGenericParametersDetail_1 = require("./FunctionLikeDeclarationGenericParametersDetail");
const helpers_1 = require("./helpers");
const isGetTypeCall_1 = require("./isGetTypeCall");
function getGenericParametersDetails(node, context, relatedDeclarations) {
    var _a;
    if (!((_a = node.typeParameters) === null || _a === void 0 ? void 0 : _a.length)) {
        return {};
    }
    let genericParametersDetail = node[FunctionLikeDeclarationGenericParametersDetail_1.STATE_PROP];
    if (genericParametersDetail) {
        return genericParametersDetail;
    }
    const symbol = context.typeChecker.getTypeAtLocation(node).getSymbol();
    if (symbol !== undefined) {
        if ((0, helpers_1.hasReflectJsDoc)(symbol)) {
            const genericParams = node.typeParameters.map(p => p.name.escapedText.toString());
            const state = {
                usedGenericParameters: genericParams,
                indexesOfGenericParameters: genericParams.map((_, index) => index),
                declaredParametersCount: relatedDeclarations.length != 0
                    ? Math.max(node.parameters.length, ...relatedDeclarations.map(x => x.parameters.length))
                    : node.parameters.length,
                requestedGenericsReflection: true
            };
            node[FunctionLikeDeclarationGenericParametersDetail_1.STATE_PROP] = state;
            return state;
        }
    }
    return context.createNestedContext(exploreGetTypeCalls, context => {
        context.visitFunctionLikeDeclaration(node);
        if (context.usedGenericParameters.length) {
            const genericParams = node.typeParameters.map(p => p.name.escapedText.toString());
            const state = {
                usedGenericParameters: context.usedGenericParameters,
                indexesOfGenericParameters: context.usedGenericParameters.map(p => genericParams.indexOf(p)),
                declaredParametersCount: node.parameters.length
            };
            node[FunctionLikeDeclarationGenericParametersDetail_1.STATE_PROP] = state;
            return state;
        }
        else {
            node[FunctionLikeDeclarationGenericParametersDetail_1.STATE_PROP] = {};
        }
        return {};
    });
}
exports.getGenericParametersDetails = getGenericParametersDetails;
function exploreGetTypeCalls(node, context) {
    let genericTypeNode;
    if ((genericTypeNode = (0, isGetTypeCall_1.isGetTypeCall)(node, context)) !== false) {
        let genericType = context.typeChecker.getTypeAtLocation(genericTypeNode);
        if (genericType.flags == ts.TypeFlags.TypeParameter
            && context.usedGenericParameters != undefined
            && ts.isTypeReferenceNode(genericTypeNode) && ts.isIdentifier(genericTypeNode.typeName)) {
            context.usedGenericParameters.push(genericTypeNode.typeName.escapedText.toString());
        }
        return node;
    }
    return ts.visitEachChild(node, context.visitor, context.transformationContext);
}
//# sourceMappingURL=getGenericParametersDetails.js.map