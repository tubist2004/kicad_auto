"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNativeTypeDescription = void 0;
const tst_reflect_1 = require("tst-reflect");
const ts = require("typescript");
const getTypeCall_1 = require("./getTypeCall");
const helpers_1 = require("./helpers");
function getNativeTypeCtorName(name) {
    if (!name) {
        return undefined;
    }
    switch (name.toLowerCase()) {
        case "bigint":
            return "BigInt";
        case "symbol":
            return "Symbol";
        case "string":
            return "String";
        case "number":
            return "Number";
        case "boolean":
            return "Boolean";
        case "array":
            return "Array";
    }
    return undefined;
}
function getNativeTypeCtor(name) {
    const nativeCtorType = getNativeTypeCtorName(name);
    if (nativeCtorType === undefined) {
        return undefined;
    }
    return ts.factory.createFunctionExpression(undefined, undefined, undefined, undefined, [], undefined, ts.factory.createBlock([
        ts.factory.createReturnStatement(ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier("Promise"), ts.factory.createIdentifier("resolve")), undefined, [
            ts.factory.createIdentifier(nativeCtorType)
        ]))
    ], true));
}
function getNativeTypeDescription(type, context) {
    if (type["intrinsicName"] !== undefined) {
        return {
            ok: true,
            typeDescription: {
                n: type.intrinsicName,
                k: tst_reflect_1.TypeKind.Native,
                ctor: getNativeTypeCtor(type.intrinsicName),
                ctors: undefined,
                decs: undefined,
                props: undefined
            }
        };
    }
    if ((0, helpers_1.isArrayType)(type)) {
        const typeArguments = context.typeChecker.getTypeArguments(type);
        if (typeArguments.length == 1) {
            return {
                ok: true,
                typeDescription: {
                    n: "Array",
                    fn: "Array#" + (0, helpers_1.getTypeId)(type, context.typeChecker),
                    isg: true,
                    gtd: type.target === type
                        ? undefined
                        : (0, getTypeCall_1.getTypeCall)(type.target, undefined, context),
                    k: tst_reflect_1.TypeKind.Native,
                    ctor: getNativeTypeCtor("Array"),
                    args: [(0, getTypeCall_1.getTypeCall)(typeArguments[0], undefined, context)]
                }
            };
        }
    }
    if ((0, helpers_1.isPromiseType)(type)) {
        const typeArguments = context.typeChecker.getTypeArguments(type);
        if (typeArguments.length == 1) {
            return {
                ok: true,
                typeDescription: {
                    n: "Promise",
                    fn: "Promise#" + (0, helpers_1.getTypeId)(type, context.typeChecker),
                    isg: true,
                    gtd: type.target === type
                        ? undefined
                        : (0, getTypeCall_1.getTypeCall)(type.target, undefined, context),
                    k: tst_reflect_1.TypeKind.Native,
                    ctor: getNativeTypeCtor("Promise"),
                    args: [(0, getTypeCall_1.getTypeCall)(typeArguments[0], undefined, context)]
                }
            };
        }
    }
    return {
        ok: false
    };
}
exports.getNativeTypeDescription = getNativeTypeDescription;
//# sourceMappingURL=getNativeTypeDescription.js.map