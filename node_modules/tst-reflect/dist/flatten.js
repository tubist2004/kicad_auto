"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flatten = exports.setTypeBuilder = void 0;
let _TypeBuilder = {};
function setTypeBuilder(typeBuilder) {
    _TypeBuilder = typeBuilder;
}
exports.setTypeBuilder = setTypeBuilder;
function flatten(typeToFlatten) {
    var _a, _b, _c, _d;
    const interfaceMembers = (_b = (_a = typeToFlatten.interface) === null || _a === void 0 ? void 0 : _a.flattenInheritedMembers()) !== null && _b !== void 0 ? _b : { properties: {}, methods: {} };
    const baseTypeMembers = (_d = (_c = typeToFlatten.baseType) === null || _c === void 0 ? void 0 : _c.flattenInheritedMembers()) !== null && _d !== void 0 ? _d : { properties: {}, methods: {} };
    const properties = Object.assign(interfaceMembers.properties, baseTypeMembers.properties);
    const methods = Object.assign(interfaceMembers.methods, baseTypeMembers.methods);
    if (typeToFlatten.isUnionOrIntersection()) {
        // Map of properties/methods through united types
        const propertyUnitedMap = new Map();
        const methodUnitedMap = new Map();
        for (const type of typeToFlatten.types) {
            for (let property of type.getProperties()) {
                let array = propertyUnitedMap.get(property.name);
                if (!array) {
                    propertyUnitedMap.set(property.name, array = []);
                }
                array.push(property);
            }
            for (let method of type.getMethods()) {
                let array = methodUnitedMap.get(method.name);
                if (!array) {
                    methodUnitedMap.set(method.name, array = []);
                }
                array.push(method);
            }
        }
        if (typeToFlatten.isUnion()) {
            const typesCount = typeToFlatten.types.length;
            // Process Properties
            for (let [propertyName, unitedProperties] of propertyUnitedMap) {
                // Only properties present in all the types are in result type
                if (unitedProperties.length == typesCount) {
                    properties[propertyName] = _TypeBuilder
                        .createProperty({
                        n: propertyName,
                        t: _TypeBuilder.createUnion(unitedProperties.map(prop => prop.type)).build(),
                        o: unitedProperties.every(prop => prop.optional),
                        ro: unitedProperties.some(prop => prop.readonly)
                    })
                        .build();
                }
            }
            // TODO: Process Methods
        }
        else if (typeToFlatten.isIntersection()) {
            // Process Properties
            for (let [propertyName, intersectionedProperties] of propertyUnitedMap) {
                properties[propertyName] = _TypeBuilder
                    .createProperty({
                    n: propertyName,
                    t: _TypeBuilder.createIntersection(intersectionedProperties.map(prop => prop.type)).build(),
                    o: intersectionedProperties.every(prop => prop.optional),
                    ro: intersectionedProperties.some(prop => prop.readonly)
                })
                    .build();
            }
            // TODO: Process Methods
        }
    }
    for (let property of typeToFlatten.getProperties()) {
        properties[property.name] = property;
    }
    for (let method of typeToFlatten.getMethods()) {
        methods[method.name] = method;
    }
    return {
        properties,
        methods
    };
}
exports.flatten = flatten;
