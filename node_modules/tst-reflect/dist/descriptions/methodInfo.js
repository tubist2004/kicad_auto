"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConstructorInfoActivator = exports.ConstructorInfo = exports.MethodInfoActivator = exports.MethodInfo = exports.MethodBase = void 0;
const mapper_1 = require("../mapper");
const Type_1 = require("../Type");
const parameter_1 = require("./parameter");
class MethodBase {
    /**
     * Internal constructor
     * @internal
     */
    constructor(params) {
        this._parameters = (params === null || params === void 0 ? void 0 : params.map(param => new parameter_1.Parameter(param))) || [];
    }
    /**
     * Parameters of this method
     */
    getParameters() {
        return this._parameters.slice();
    }
}
exports.MethodBase = MethodBase;
/**
 * Method details
 */
class MethodInfo extends MethodBase {
    /**
     * Internal method constructor
     * @internal
     */
    constructor(description) {
        var _a, _b;
        super(description.params);
        if (new.target != MethodInfoActivator) {
            throw new Error("You cannot create instance of Method manually!");
        }
        this._name = description.n;
        this._typeParameters = ((_a = description.tp) === null || _a === void 0 ? void 0 : _a.map(t => new Type_1.LazyType(t))) || [];
        this._returnType = new Type_1.LazyType(description.rt);
        this._optional = description.o;
        this._accessModifier = description.am;
        this._decorators = ((_b = description.d) === null || _b === void 0 ? void 0 : _b.map(mapper_1.Mapper.mapDecorators)) || [];
    }
    /**
     * Name of this method
     */
    get name() {
        return this._name;
    }
    /**
     * Return type of this method
     */
    get returnType() {
        return this._returnType.type;
    }
    /**
     * Method is optional
     */
    get optional() {
        return this._optional;
    }
    /**
     * Access modifier
     */
    get accessModifier() {
        return this._accessModifier;
    }
    /**
     * Returns list of generic type parameter.
     * @return {Array<Type>}
     */
    getTypeParameters() {
        return this._typeParameters.map(tp => tp.type);
    }
    /**
     * Returns array of decorators
     */
    getDecorators() {
        return this._decorators.slice();
    }
}
exports.MethodInfo = MethodInfo;
/**
 * @internal
 */
class MethodInfoActivator extends MethodInfo {
}
exports.MethodInfoActivator = MethodInfoActivator;
/**
 * Constructor details
 */
class ConstructorInfo extends MethodBase {
    /**
     * Internal constructor
     * @internal
     */
    constructor(description) {
        super(description.params);
        if (new.target != ConstructorInfoActivator) {
            throw new Error("You cannot create instance of Constructor manually!");
        }
    }
}
exports.ConstructorInfo = ConstructorInfo;
/**
 * @internal
 */
class ConstructorInfoActivator extends ConstructorInfo {
}
exports.ConstructorInfoActivator = ConstructorInfoActivator;
